# Regras do Cursor para White Label Ecommerce

## üö® Regras Cr√≠ticas para Modais e Bot√µes

### 1. Bot√µes dentro de Modais DEVEM ter `data-modal-button="true"`

**Problema:** O CSS global em `editable-preview.tsx` desabilita `pointer-events` em todos os bot√µes que n√£o t√™m `data-modal-button="true"`. Isso impede que bot√µes dentro de modais sejam clic√°veis.

**Solu√ß√£o:** SEMPRE adicione `data-modal-button="true"` em bot√µes que est√£o dentro de modais renderizados via `createPortal` ou dentro de elementos com `data-modal="true"`.

**Exemplo:**
```tsx
// ‚úÖ CORRETO
<button
  type="button"
  data-modal-button="true"
  onClick={handleClick}
  className="..."
>
  Clique aqui
</button>

// ‚ùå ERRADO - bot√£o n√£o ser√° clic√°vel
<button
  type="button"
  onClick={handleClick}
  className="..."
>
  Clique aqui
</button>
```

**Quando aplicar:**
- Bot√µes dentro de modais de configura√ß√£o (HeroBannerSettings, ProductShowcase, etc.)
- Bot√µes dentro de elementos com `data-modal="true"`
- Qualquer bot√£o renderizado via `createPortal` que precisa ser clic√°vel

### 2. NUNCA use `confirm()`, `alert()` ou `prompt()` em iframes com sandbox

**Problema:** O iframe do preview est√° com sandbox que bloqueia modais nativos do navegador. Chamadas a `confirm()`, `alert()` ou `prompt()` ser√£o ignoradas silenciosamente.

**Solu√ß√£o:** Use modais customizados ou componentes de di√°logo para confirma√ß√µes e mensagens.

**Exemplo:**
```tsx
// ‚ùå ERRADO - n√£o funciona em iframe sandboxed
const confirmed = confirm('Tem certeza?');
if (confirmed) {
  handleAction();
}

// ‚úÖ CORRETO - usar modal customizado ou remover confirma√ß√£o
const handleClick = () => {
  // Remover diretamente ou usar modal customizado
  handleAction();
};
```

**Alternativas:**
- Remover confirma√ß√£o se a a√ß√£o for revers√≠vel
- Criar modal de confirma√ß√£o customizado usando React
- Usar biblioteca de di√°logos (ex: Radix UI Dialog)

### 3. Arrays em Craft.js Props DEVEM ser Imut√°veis

**Problema:** Craft.js n√£o detecta mudan√ßas quando arrays s√£o mutados diretamente. Isso impede re-renders e atualiza√ß√µes visuais.

**Solu√ß√£o:** SEMPRE crie novos arrays ao atualizar props do Craft.js. Use m√©todos imut√°veis como `filter()`, `map()`, spread operator, etc.

**Exemplo:**
```tsx
// ‚úÖ CORRETO - criar novo array
setProp((props: any) => {
  const currentImages = props.backgroundImages || [];
  const newImages = currentImages.filter((_: string, i: number) => i !== index);
  props.backgroundImages = newImages; // Novo array, Craft.js detecta mudan√ßa
});

// ‚ùå ERRADO - muta√ß√£o direta, Craft.js n√£o detecta
setProp((props: any) => {
  props.backgroundImages.splice(index, 1); // Muta√ß√£o direta!
});
```

**Padr√£o recomendado:**
```tsx
// Para remover item
const newArray = oldArray.filter((_, i) => i !== index);

// Para adicionar item
const newArray = [...oldArray, newItem];

// Para atualizar item
const newArray = [...oldArray];
newArray[index] = newValue;

// Para reordenar
const newArray = [...oldArray];
[newArray[i], newArray[j]] = [newArray[j], newArray[i]];
```

### 4. Obter Props Atuais DENTRO do Callback do setProp

**Problema:** Ao obter props antes de chamar `setProp`, voc√™ pode estar usando valores desatualizados devido a closures ou timing.

**Solu√ß√£o:** Sempre obtenha o valor atual das props DENTRO do callback do `setProp`.

**Exemplo:**
```tsx
// ‚úÖ CORRETO - obter valor atual dentro do callback
setProp((props: any) => {
  const currentImages = props.backgroundImages || []; // Valor atualizado
  const newImages = currentImages.filter((_, i) => i !== index);
  props.backgroundImages = newImages;
});

// ‚ùå ERRADO - pode usar valor desatualizado
const currentImages = props.backgroundImages || []; // Pode estar desatualizado
setProp((props: any) => {
  const newImages = currentImages.filter((_, i) => i !== index);
  props.backgroundImages = newImages;
});
```

## üìã Checklist ao Criar/Modificar Modais

- [ ] Todos os bot√µes dentro do modal t√™m `data-modal-button="true"`?
- [ ] N√£o h√° uso de `confirm()`, `alert()` ou `prompt()`?
- [ ] Arrays s√£o atualizados de forma imut√°vel?
- [ ] Props s√£o obtidas dentro do callback do `setProp`?
- [ ] Eventos de bot√µes t√™m `e.preventDefault()` e `e.stopPropagation()` quando necess√°rio?
- [ ] O modal tem `data-modal="true"` no elemento raiz?
- [ ] O overlay tem `onClick` para fechar o modal?

## üéØ Padr√µes de C√≥digo

### Modal com Bot√µes Clic√°veis
```tsx
function MyModal({ onClose, isOpen }: { onClose: () => void; isOpen: boolean }) {
  const modalRef = React.useRef<HTMLDivElement>(null);
  
  const modalContent = (
    <>
      <div 
        className="fixed inset-0 z-[9998] bg-black/50"
        onClick={onClose}
      />
      <div
        ref={modalRef}
        data-modal="true"
        className="fixed z-[9999] ..."
        onClick={(e) => e.stopPropagation()}
        onMouseDown={(e) => {
          const target = e.target as HTMLElement;
          if (target.closest('button')) {
            return; // Permitir eventos de bot√µes
          }
          e.stopPropagation();
        }}
      >
        {/* Conte√∫do do modal */}
        <button
          type="button"
          data-modal-button="true" // ‚úÖ OBRIGAT√ìRIO
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            handleAction();
          }}
          className="..."
        >
          A√ß√£o
        </button>
      </div>
    </>
  );

  return typeof document !== 'undefined' 
    ? createPortal(modalContent, document.body)
    : null;
}
```

### Atualizar Array no Craft.js
```tsx
// Remover item
const handleRemove = React.useCallback((index: number) => {
  setProp((props: any) => {
    const current = props.items || [];
    props.items = current.filter((_: any, i: number) => i !== index);
  });
}, [setProp]);

// Adicionar item
const handleAdd = React.useCallback((newItem: any) => {
  setProp((props: any) => {
    const current = props.items || [];
    props.items = [...current, newItem];
  });
}, [setProp]);

// Reordenar
const handleMove = React.useCallback((index: number, direction: 'up' | 'down') => {
  setProp((props: any) => {
    const current = props.items || [];
    const newIndex = direction === 'up' ? index - 1 : index + 1;
    if (newIndex < 0 || newIndex >= current.length) return;
    
    const newItems = [...current];
    [newItems[index], newItems[newIndex]] = [newItems[newIndex], newItems[index]];
    props.items = newItems;
  });
}, [setProp]);
```

## üîç Debugging

Se bot√µes dentro de modais n√£o est√£o funcionando:

1. Verifique se t√™m `data-modal-button="true"`
2. Verifique se o CSS global n√£o est√° bloqueando (inspecione `pointer-events` no DevTools)
3. Verifique se eventos n√£o est√£o sendo bloqueados por `stopPropagation()` no elemento pai
4. Verifique se o modal tem `data-modal="true"` no elemento raiz

Se arrays n√£o atualizam no Craft.js:

1. Verifique se est√° criando um novo array (n√£o mutando o existente)
2. Verifique se est√° obtendo o valor atual dentro do callback do `setProp`
3. Verifique se o `setProp` est√° dispon√≠vel e √© uma fun√ß√£o
4. Adicione logs para verificar se `setProp` est√° sendo chamado

## üìù Notas Adicionais

- Sempre use `React.useCallback` para handlers que s√£o passados como props ou usados em depend√™ncias
- Use `useRef` para elementos DOM que precisam ser acessados diretamente
- Use `createPortal` para renderizar modais fora da hierarquia do Craft.js
- Teste sempre no contexto do editor (iframe) e na loja (renderiza√ß√£o direta)



